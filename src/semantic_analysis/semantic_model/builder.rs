use super::*;
use crate::SemanticEvent;
use crate::SemanticEvent::*;

use air_r_syntax::{RRoot, RSyntaxNode, TextRange};
use rustc_hash::FxHashMap;
use std::collections::hash_map::Entry;

pub struct SemanticModelBuilder {
    root: RRoot,
    binding_node_by_start: FxHashMap<TextSize, RSyntaxNode>,
    scope_node_by_range: FxHashMap<TextRange, RSyntaxNode>,
    globals: Vec<SemanticModelGlobalBindingData>,
    globals_by_name: FxHashMap<String, Option<u32>>,
    scopes: Vec<SemanticModelScopeData>,
    scope_range_by_start: FxHashMap<TextSize, BTreeSet<Interval<u32, ScopeId>>>,
    bindings: Vec<SemanticModelBindingData>,
    bindings_by_start: FxHashMap<TextSize, BindingId>,
    declared_at_by_start: FxHashMap<TextSize, BindingId>,
    unresolved_references: Vec<SemanticModelUnresolvedReference>,
}

impl SemanticModelBuilder {
    pub fn new(root: RRoot) -> Self {
        Self {
            root,
            binding_node_by_start: FxHashMap::default(),
            scope_node_by_range: FxHashMap::default(),
            globals: vec![],
            globals_by_name: FxHashMap::default(),
            scopes: vec![],
            scope_range_by_start: FxHashMap::default(),
            bindings: vec![],
            bindings_by_start: FxHashMap::default(),
            declared_at_by_start: FxHashMap::default(),
            unresolved_references: Vec::new(),
        }
    }

    #[inline]
    pub fn push_node(&mut self, node: &RSyntaxNode) {
        use RSyntaxKind::*;
        match node.kind() {
            R_IDENTIFIER => {
                self.binding_node_by_start
                    .insert(node.text_trimmed_range().start(), node.clone());
            }
            R_FUNCTION_DEFINITION => {
                self.scope_node_by_range
                    .insert(node.text_trimmed_range(), node.clone());
            }
            _ => {}
        }
    }

    #[inline]
    pub fn push_global(&mut self, name: impl Into<String>) {
        self.globals_by_name.insert(name.into(), None);
    }

    #[inline]
    pub fn push_event(&mut self, e: SemanticEvent) {
        match e {
            ScopeStarted { range, parent_scope_id, is_function } => {
                // Scopes will be raised in order
                let scope_id = ScopeId::new(self.scopes.len());

                self.scopes.push(SemanticModelScopeData {
                    range,
                    parent: parent_scope_id,
                    children: vec![],
                    bindings: vec![],
                    bindings_by_name: FxHashMap::default(),
                    read_references: vec![],
                    write_references: vec![],
                    is_function,
                });

                if let Some(parent_scope_id) = parent_scope_id {
                    self.scopes[parent_scope_id.index()].children.push(scope_id);
                }

                let start = range.start();
                self.scope_range_by_start
                    .entry(start)
                    .or_default()
                    .insert(Interval {
                        start: start.into(),
                        stop: range.end().into(),
                        val: scope_id,
                    });
            }
            ScopeEnded { .. } => {}
            DeclarationFound { range, scope_id } => {
                let binding_scope_id = scope_id;

                // SAFETY: this scope id is guaranteed to exist because they were generated by the
                // event extractor
                debug_assert!((binding_scope_id.index()) < self.scopes.len());

                let binding_id = BindingId::new(self.bindings.len());
                self.bindings.push(SemanticModelBindingData {
                    range,
                    references: Vec::new(),
                    export_by_start: smallvec::SmallVec::new(),
                });
                self.bindings_by_start.insert(range.start(), binding_id);

                let scope = &mut self.scopes[binding_scope_id.index()];

                scope.bindings.push(binding_id);
                // Handle bindings with a bogus name
                if let Some(node) = self.binding_node_by_start.get(&range.start()) {
                    if let Some(node) = RIdentifier::cast_ref(node) {
                        if let Ok(name_token) = node.name_token() {
                            let name = name_token.token_text_trimmed();
                            scope.bindings_by_name.insert(name, binding_id);
                        }
                    }
                }
            }
            Read { range, declaration_at, scope_id } => {
                let binding_id = self.bindings_by_start[&declaration_at];
                let binding = &mut self.bindings[binding_id.index()];
                let reference_id = ReferenceId::new(binding_id, binding.references.len());
                binding.references.push(SemanticModelReference {
                    range_start: range.start(),
                    ty: SemanticModelReferenceType::Read {},
                });

                let scope = &mut self.scopes[scope_id.index()];
                scope.read_references.push(reference_id);

                self.declared_at_by_start.insert(range.start(), binding_id);
            }
            Write { range, declaration_at, scope_id } => {
                // First ensure the binding exists by creating it if necessary
                let binding_id = match self.bindings_by_start.get(&declaration_at) {
                    Some(id) => *id,
                    None => {
                        // Create a new binding
                        let binding_id = BindingId::new(self.bindings.len());
                        self.bindings.push(SemanticModelBindingData {
                            range: TextRange::new(
                                declaration_at,
                                declaration_at + TextSize::from(1),
                            ),
                            references: Vec::new(),
                            export_by_start: smallvec::SmallVec::new(),
                        });
                        self.bindings_by_start.insert(declaration_at, binding_id);

                        // Add it to the current scope
                        let scope = &mut self.scopes[scope_id.index()];
                        scope.bindings.push(binding_id);

                        // Add to bindings_by_name if we can get the name
                        if let Some(node) = self.binding_node_by_start.get(&declaration_at) {
                            if let Some(node) = RIdentifier::cast_ref(node) {
                                if let Ok(name_token) = node.name_token() {
                                    let name = name_token.token_text_trimmed();
                                    scope.bindings_by_name.insert(name, binding_id);
                                }
                            }
                        }

                        binding_id
                    }
                };

                // Add the write reference
                let binding = &mut self.bindings[binding_id.index()];
                let reference_id = ReferenceId::new(binding_id, binding.references.len());
                binding.references.push(SemanticModelReference {
                    range_start: range.start(),
                    ty: SemanticModelReferenceType::Write {},
                });

                let scope = &mut self.scopes[scope_id.index()];
                scope.write_references.push(reference_id);

                self.declared_at_by_start.insert(range.start(), binding_id);
            }
            UnresolvedReference { is_read, range } => {
                let ty = if is_read {
                    SemanticModelReferenceType::Read {}
                } else {
                    SemanticModelReferenceType::Write {}
                };

                let node = &self.binding_node_by_start[&range.start()];
                let name = node.text_trimmed().to_string();

                match self.globals_by_name.entry(name) {
                    Entry::Occupied(mut entry) => {
                        let entry = entry.get_mut();
                        match entry {
                            Some(index) => {
                                self.globals[(*index) as usize].references.push(
                                    SemanticModelGlobalReferenceData {
                                        range_start: range.start(),
                                        ty,
                                    },
                                );
                            }
                            None => {
                                let id = self.globals.len() as u32;
                                self.globals.push(SemanticModelGlobalBindingData {
                                    references: vec![SemanticModelGlobalReferenceData {
                                        range_start: range.start(),
                                        ty,
                                    }],
                                });
                                *entry = Some(id);
                            }
                        }
                    }
                    Entry::Vacant(_) => self
                        .unresolved_references
                        .push(SemanticModelUnresolvedReference { range }),
                }
            }
        }
    }

    #[inline]
    pub fn build(self) -> SemanticModel {
        let data = SemanticModelData {
            root: self.root,
            scopes: self.scopes,
            scope_by_range: Lapper::new(
                self.scope_range_by_start
                    .iter()
                    .flat_map(|(_, scopes)| scopes.iter())
                    .cloned()
                    .collect(),
            ),
            binding_node_by_start: self.binding_node_by_start,
            scope_node_by_range: self.scope_node_by_range,
            bindings: self.bindings,
            bindings_by_start: self.bindings_by_start,
            declared_at_by_start: self.declared_at_by_start,
            unresolved_references: self.unresolved_references,
            globals: self.globals,
        };
        SemanticModel::new(data)
    }
}
